#!/usr/bin/env bash
# sync-security-incidents.sh
# shellcheck shell=bash
#
# Auto-generate the Renovate security incidents aggregator preset
#
# Usage
#   ./sync-security-incidents.sh
#
# Behavior
# - Collect all JSON presets under security/incidents/**
# - Generate security/_incidents.json with a sorted 'extends' array
#
# Safety settings
# - set -e / exit on first error
# - set -u / fail on unset vars
# - set -o pipefail / fail a pipeline if any command fails
# - IFS=$'\n\t' / split on newline and tab only

set -euo pipefail
IFS=$'\n\t'

INCIDENTS_DIR="security/incidents"
AGGREGATOR_JSON="security/_incidents.json"
PRESET_PREFIX="Kong/public-shared-renovate//"

# shellcheck source=_common.sh
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "${SCRIPT_DIR}/_common.sh"

# list incident files, nul-delimited, stable sort
collect_incident_files() {
  local files
  mapfile -d '' -t files < <(
    find "$INCIDENTS_DIR" -type f -name '*.json' -print0 | sort -z
  )
  printf '%s\0' "${files[@]}"
}

# output sorted unique preset ids (one per line)
sorted_incident_ids() {
  local -a ids=()
  local f rel rel_no_ext id
  while IFS= read -r -d '' f; do
    rel=$(common::relpath "$f")
    rel_no_ext=$(common::strip_json_ext "$rel")
    id=$(common::preset_id_from_rel_noext "$PRESET_PREFIX" "$rel_no_ext")
    ids+=("$id")
  done < <(collect_incident_files)

  ((${#ids[@]})) && printf '%s\n' "${ids[@]}" | sort -u
}

# print final JSON to stdout
generate_json() {
  local ids extends_json
  ids="$(sorted_incident_ids || true)"
  extends_json="$(
    printf '%s\n' "${ids:-}" | jq -R -s 'split("\n") | map(select(length>0))'
  )"

  jq -n \
    --argjson extends "${extends_json:-[]}" \
    --arg schema "https://docs.renovatebot.com/renovate-schema.json" \
    --arg d1 " [AUTOGENERATED] Do not edit this file manually." \
    --arg d2 " This aggregator preset is maintained by CI and composes all presets under" \
    --arg d3 " security/incidents/**. To add or remove an incident rule, modify files in" \
    --arg d4 " security/incidents/ and open a PR. The CI workflow will update this file" \
    --arg d5 " in your PR and keep entries sorted alphabetically." \
    '{
      "$schema": $schema,
      "description": [$d1,$d2,$d3,$d4,$d5],
      "extends": $extends
    }'
}

# write only if content changed; return 0 if changed, 1 otherwise
write_if_changed() {
  local tmp
  tmp="$(mktemp)"
  generate_json > "$tmp"

  if [[ ! -f "$AGGREGATOR_JSON" ]] || ! diff -u "$AGGREGATOR_JSON" "$tmp" > /dev/null 2>&1; then
    mkdir -p "$(dirname "$AGGREGATOR_JSON")"
    mv "$tmp" "$AGGREGATOR_JSON"
    common::log "updated $AGGREGATOR_JSON"
    return 0
  fi

  rm -f "$tmp"
  common::log "no changes in $AGGREGATOR_JSON"
  return 1
}

main() {
  common::require_tools jq git

  if [[ ! -d $INCIDENTS_DIR ]]; then
    common::log "no $INCIDENTS_DIR directory, nothing to do"
    exit 0
  fi

  # Generate and write aggregator if content differs
  write_if_changed || true
}

# allow sourcing in potential tests
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  main "$@"
fi
